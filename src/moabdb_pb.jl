# Autogenerated using ProtoBuf.jl v1.0.9 on 2022-12-14T22:05:51.630
# original file: /Users/jacksoncoxson/Local_Code/jl_test/src/moabdb.proto (proto3 syntax)

module moabdb_pb

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Request, Response

struct Request
    symbol::String
    datatype::String
    start::UInt32
    var"#end"::UInt32
    username::String
    token::String
end
PB.reserved_fields(::Type{Request}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[7:15])
PB.default_values(::Type{Request}) = (;symbol = "", datatype = "", start = zero(UInt32), var"#end" = zero(UInt32), username = "", token = "")
PB.field_numbers(::Type{Request}) = (;symbol = 1, datatype = 2, start = 3, var"#end" = 4, username = 5, token = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Request})
    symbol = ""
    datatype = ""
    start = zero(UInt32)
    var"#end" = zero(UInt32)
    username = ""
    token = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            symbol = PB.decode(d, String)
        elseif field_number == 2
            datatype = PB.decode(d, String)
        elseif field_number == 3
            start = PB.decode(d, UInt32)
        elseif field_number == 4
            var"#end" = PB.decode(d, UInt32)
        elseif field_number == 5
            username = PB.decode(d, String)
        elseif field_number == 6
            token = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return Request(symbol, datatype, start, var"#end", username, token)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Request)
    initpos = position(e.io)
    !isempty(x.symbol) && PB.encode(e, 1, x.symbol)
    !isempty(x.datatype) && PB.encode(e, 2, x.datatype)
    x.start != zero(UInt32) && PB.encode(e, 3, x.start)
    x.var"#end" != zero(UInt32) && PB.encode(e, 4, x.var"#end")
    !isempty(x.username) && PB.encode(e, 5, x.username)
    !isempty(x.token) && PB.encode(e, 6, x.token)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Request)
    encoded_size = 0
    !isempty(x.symbol) && (encoded_size += PB._encoded_size(x.symbol, 1))
    !isempty(x.datatype) && (encoded_size += PB._encoded_size(x.datatype, 2))
    x.start != zero(UInt32) && (encoded_size += PB._encoded_size(x.start, 3))
    x.var"#end" != zero(UInt32) && (encoded_size += PB._encoded_size(x.var"#end", 4))
    !isempty(x.username) && (encoded_size += PB._encoded_size(x.username, 5))
    !isempty(x.token) && (encoded_size += PB._encoded_size(x.token, 6))
    return encoded_size
end

struct Response
    code::UInt32
    message::String
    data::Vector{UInt8}
end
PB.reserved_fields(::Type{Response}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4:15])
PB.default_values(::Type{Response}) = (;code = zero(UInt32), message = "", data = UInt8[])
PB.field_numbers(::Type{Response}) = (;code = 1, message = 2, data = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Response})
    code = zero(UInt32)
    message = ""
    data = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            code = PB.decode(d, UInt32)
        elseif field_number == 2
            message = PB.decode(d, String)
        elseif field_number == 3
            data = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return Response(code, message, data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Response)
    initpos = position(e.io)
    x.code != zero(UInt32) && PB.encode(e, 1, x.code)
    !isempty(x.message) && PB.encode(e, 2, x.message)
    !isempty(x.data) && PB.encode(e, 3, x.data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Response)
    encoded_size = 0
    x.code != zero(UInt32) && (encoded_size += PB._encoded_size(x.code, 1))
    !isempty(x.message) && (encoded_size += PB._encoded_size(x.message, 2))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 3))
    return encoded_size
end
end # module
